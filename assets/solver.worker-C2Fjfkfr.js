(function(){"use strict";var M=63710088e-1,ft={centimeters:M*100,centimetres:M*100,degrees:360/(2*Math.PI),feet:M*3.28084,inches:M*39.37,kilometers:M/1e3,kilometres:M/1e3,meters:M,metres:M,miles:M/1609.344,millimeters:M*1e3,millimetres:M*1e3,nauticalmiles:M/1852,radians:1,yards:M*1.0936};function O(t,e,r={}){const n={type:"Feature"};return(r.id===0||r.id)&&(n.id=r.id),r.bbox&&(n.bbox=r.bbox),n.properties=e||{},n.geometry=t,n}function x(t,e,r={}){if(!t)throw new Error("coordinates is required");if(!Array.isArray(t))throw new Error("coordinates must be an Array");if(t.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!pt(t[0])||!pt(t[1]))throw new Error("coordinates must contain numbers");return O({type:"Point",coordinates:t},e,r)}function qt(t,e,r={}){for(const i of t){if(i.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");if(i[i.length-1].length!==i[0].length)throw new Error("First and last Position are not equivalent.");for(let o=0;o<i[i.length-1].length;o++)if(i[i.length-1][o]!==i[0][o])throw new Error("First and last Position are not equivalent.")}return O({type:"Polygon",coordinates:t},e,r)}function X(t,e,r={}){if(t.length<2)throw new Error("coordinates must be an array of two or more positions");return O({type:"LineString",coordinates:t},e,r)}function Y(t,e={}){const r={type:"FeatureCollection"};return e.id&&(r.id=e.id),e.bbox&&(r.bbox=e.bbox),r.features=t,r}function Gt(t,e,r={}){return O({type:"MultiLineString",coordinates:t},e,r)}function ut(t,e="kilometers"){const r=ft[e];if(!r)throw new Error(e+" units is invalid");return t*r}function Tt(t,e="kilometers"){const r=ft[e];if(!r)throw new Error(e+" units is invalid");return t/r}function lt(t){return t%(2*Math.PI)*180/Math.PI}function N(t){return t%360*Math.PI/180}function ht(t,e="kilometers",r="kilometers"){if(!(t>=0))throw new Error("length must be a positive number");return ut(Tt(t,e),r)}function pt(t){return!isNaN(t)&&t!==null&&!Array.isArray(t)}function q(t){if(!t)throw new Error("coord is required");if(!Array.isArray(t)){if(t.type==="Feature"&&t.geometry!==null&&t.geometry.type==="Point")return[...t.geometry.coordinates];if(t.type==="Point")return[...t.coordinates]}if(Array.isArray(t)&&t.length>=2&&!Array.isArray(t[0])&&!Array.isArray(t[1]))return[...t];throw new Error("coord must be GeoJSON Point or an Array of numbers")}function Nt(t){if(Array.isArray(t))return t;if(t.type==="Feature"){if(t.geometry!==null)return t.geometry.coordinates}else if(t.coordinates)return t.coordinates;throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")}function yt(t,e,r){if(!t)throw new Error("No feature passed");if(!r)throw new Error(".featureOf() requires a name");if(!t||t.type!=="Feature"||!t.geometry)throw new Error("Invalid input to "+r+", Feature with geometry required");if(!t.geometry||t.geometry.type!==e)throw new Error("Invalid input to "+r+": must be a "+e+", given "+t.geometry.type)}function H(t){return t.type==="Feature"?t.geometry:t}function rt(t,e,r={}){var n=q(t),i=q(e),o=N(i[1]-n[1]),s=N(i[0]-n[0]),a=N(n[1]),u=N(i[1]),f=Math.pow(Math.sin(o/2),2)+Math.pow(Math.sin(s/2),2)*Math.cos(a)*Math.cos(u);return ut(2*Math.atan2(Math.sqrt(f),Math.sqrt(1-f)),r.units)}function W(t,e,r){if(t!==null)for(var n,i,o,s,a,u,f,h=0,c=0,l,p=t.type,g=p==="FeatureCollection",d=p==="Feature",w=g?t.features.length:1,y=0;y<w;y++){f=g?t.features[y].geometry:d?t.geometry:t,l=f?f.type==="GeometryCollection":!1,a=l?f.geometries.length:1;for(var v=0;v<a;v++){var P=0,m=0;if(s=l?f.geometries[v]:f,s!==null){u=s.coordinates;var E=s.type;switch(h=0,E){case null:break;case"Point":if(e(u,c,y,P,m)===!1)return!1;c++,P++;break;case"LineString":case"MultiPoint":for(n=0;n<u.length;n++){if(e(u[n],c,y,P,m)===!1)return!1;c++,E==="MultiPoint"&&P++}E==="LineString"&&P++;break;case"Polygon":case"MultiLineString":for(n=0;n<u.length;n++){for(i=0;i<u[n].length-h;i++){if(e(u[n][i],c,y,P,m)===!1)return!1;c++}E==="MultiLineString"&&P++,E==="Polygon"&&m++}E==="Polygon"&&P++;break;case"MultiPolygon":for(n=0;n<u.length;n++){for(m=0,i=0;i<u[n].length;i++){for(o=0;o<u[n][i].length-h;o++){if(e(u[n][i][o],c,y,P,m)===!1)return!1;c++}m++}P++}break;case"GeometryCollection":for(n=0;n<s.geometries.length;n++)if(W(s.geometries[n],e)===!1)return!1;break;default:throw new Error("Unknown Geometry Type")}}}}}function zt(t,e){if(t.type==="Feature")e(t,0);else if(t.type==="FeatureCollection")for(var r=0;r<t.features.length&&e(t.features[r],r)!==!1;r++);}function dt(t,e){var r,n,i,o,s,a,u,f,h,c,l=0,p=t.type==="FeatureCollection",g=t.type==="Feature",d=p?t.features.length:1;for(r=0;r<d;r++){for(a=p?t.features[r].geometry:g?t.geometry:t,f=p?t.features[r].properties:g?t.properties:{},h=p?t.features[r].bbox:g?t.bbox:void 0,c=p?t.features[r].id:g?t.id:void 0,u=a?a.type==="GeometryCollection":!1,s=u?a.geometries.length:1,i=0;i<s;i++){if(o=u?a.geometries[i]:a,o===null){if(e(null,l,f,h,c)===!1)return!1;continue}switch(o.type){case"Point":case"LineString":case"MultiPoint":case"Polygon":case"MultiLineString":case"MultiPolygon":{if(e(o,l,f,h,c)===!1)return!1;break}case"GeometryCollection":{for(n=0;n<o.geometries.length;n++)if(e(o.geometries[n],l,f,h,c)===!1)return!1;break}default:throw new Error("Unknown Geometry Type")}}l++}}function Bt(t,e,r){var n=r;return dt(t,function(i,o,s,a,u){o===0&&r===void 0?n=i:n=e(n,i,o,s,a,u)}),n}function z(t,e){dt(t,function(r,n,i,o,s){var a=r===null?null:r.type;switch(a){case null:case"Point":case"LineString":case"Polygon":return e(O(r,i,{bbox:o,id:s}),n,0)===!1?!1:void 0}var u;switch(a){case"MultiPoint":u="Point";break;case"MultiLineString":u="LineString";break;case"MultiPolygon":u="Polygon";break}for(var f=0;f<r.coordinates.length;f++){var h=r.coordinates[f],c={type:u,coordinates:h};if(e(O(c,i),n,f)===!1)return!1}})}function $t(t,e){z(t,function(r,n,i){var o=0;if(r.geometry){var s=r.geometry.type;if(!(s==="Point"||s==="MultiPoint")){var a,u=0,f=0,h=0;if(W(r,function(c,l,p,g,d){if(a===void 0||n>u||g>f||d>h){a=c,u=n,f=g,h=d,o=0;return}var w=X([a,c],r.properties);if(e(w,n,i,d,o)===!1)return!1;o++,a=c})===!1)return!1}}})}function Wt(t){return Bt(t,(e,r)=>e+Qt(r),0)}function Qt(t){let e=0,r;switch(t.type){case"Polygon":return gt(t.coordinates);case"MultiPolygon":for(r=0;r<t.coordinates.length;r++)e+=gt(t.coordinates[r]);return e;case"Point":case"MultiPoint":case"LineString":case"MultiLineString":return 0}return 0}function gt(t){let e=0;if(t&&t.length>0){e+=Math.abs(wt(t[0]));for(let r=1;r<t.length;r++)e-=Math.abs(wt(t[r]))}return e}var Ut=M*M/2,nt=Math.PI/180;function wt(t){const e=t.length-1;if(e<=2)return 0;let r=0,n=0;for(;n<e;){const i=t[n],o=t[n+1===e?0:n+1],s=t[n+2>=e?(n+2)%e:n+2],a=i[0]*nt,u=o[1]*nt,f=s[0]*nt;r+=(f-a)*Math.sin(u),n++}return r*Ut}const R=11102230246251565e-32,b=134217729,Vt=(3+8*R)*R;function it(t,e,r,n,i){let o,s,a,u,f=e[0],h=n[0],c=0,l=0;h>f==h>-f?(o=f,f=e[++c]):(o=h,h=n[++l]);let p=0;if(c<t&&l<r)for(h>f==h>-f?(s=f+o,a=o-(s-f),f=e[++c]):(s=h+o,a=o-(s-h),h=n[++l]),o=s,a!==0&&(i[p++]=a);c<t&&l<r;)h>f==h>-f?(s=o+f,u=s-o,a=o-(s-u)+(f-u),f=e[++c]):(s=o+h,u=s-o,a=o-(s-u)+(h-u),h=n[++l]),o=s,a!==0&&(i[p++]=a);for(;c<t;)s=o+f,u=s-o,a=o-(s-u)+(f-u),f=e[++c],o=s,a!==0&&(i[p++]=a);for(;l<r;)s=o+h,u=s-o,a=o-(s-u)+(h-u),h=n[++l],o=s,a!==0&&(i[p++]=a);return(o!==0||p===0)&&(i[p++]=o),p}function Jt(t,e){let r=e[0];for(let n=1;n<t;n++)r+=e[n];return r}function Q(t){return new Float64Array(t)}const Kt=(3+16*R)*R,Xt=(2+12*R)*R,Yt=(9+64*R)*R*R,B=Q(4),vt=Q(8),mt=Q(12),Pt=Q(16),A=Q(4);function Ht(t,e,r,n,i,o,s){let a,u,f,h,c,l,p,g,d,w,y,v,P,m,E,L,C,S;const _=t-i,F=r-i,I=e-o,k=n-o;m=_*k,l=b*_,p=l-(l-_),g=_-p,l=b*k,d=l-(l-k),w=k-d,E=g*w-(m-p*d-g*d-p*w),L=I*F,l=b*I,p=l-(l-I),g=I-p,l=b*F,d=l-(l-F),w=F-d,C=g*w-(L-p*d-g*d-p*w),y=E-C,c=E-y,B[0]=E-(y+c)+(c-C),v=m+y,c=v-m,P=m-(v-c)+(y-c),y=P-L,c=P-y,B[1]=P-(y+c)+(c-L),S=v+y,c=S-v,B[2]=v-(S-c)+(y-c),B[3]=S;let D=Jt(4,B),K=Xt*s;if(D>=K||-D>=K||(c=t-_,a=t-(_+c)+(c-i),c=r-F,f=r-(F+c)+(c-i),c=e-I,u=e-(I+c)+(c-o),c=n-k,h=n-(k+c)+(c-o),a===0&&u===0&&f===0&&h===0)||(K=Yt*s+Vt*Math.abs(D),D+=_*h+k*a-(I*f+F*u),D>=K||-D>=K))return D;m=a*k,l=b*a,p=l-(l-a),g=a-p,l=b*k,d=l-(l-k),w=k-d,E=g*w-(m-p*d-g*d-p*w),L=u*F,l=b*u,p=l-(l-u),g=u-p,l=b*F,d=l-(l-F),w=F-d,C=g*w-(L-p*d-g*d-p*w),y=E-C,c=E-y,A[0]=E-(y+c)+(c-C),v=m+y,c=v-m,P=m-(v-c)+(y-c),y=P-L,c=P-y,A[1]=P-(y+c)+(c-L),S=v+y,c=S-v,A[2]=v-(S-c)+(y-c),A[3]=S;const xe=it(4,B,4,A,vt);m=_*h,l=b*_,p=l-(l-_),g=_-p,l=b*h,d=l-(l-h),w=h-d,E=g*w-(m-p*d-g*d-p*w),L=I*f,l=b*I,p=l-(l-I),g=I-p,l=b*f,d=l-(l-f),w=f-d,C=g*w-(L-p*d-g*d-p*w),y=E-C,c=E-y,A[0]=E-(y+c)+(c-C),v=m+y,c=v-m,P=m-(v-c)+(y-c),y=P-L,c=P-y,A[1]=P-(y+c)+(c-L),S=v+y,c=S-v,A[2]=v-(S-c)+(y-c),A[3]=S;const Re=it(xe,vt,4,A,mt);m=a*h,l=b*a,p=l-(l-a),g=a-p,l=b*h,d=l-(l-h),w=h-d,E=g*w-(m-p*d-g*d-p*w),L=u*f,l=b*u,p=l-(l-u),g=u-p,l=b*f,d=l-(l-f),w=f-d,C=g*w-(L-p*d-g*d-p*w),y=E-C,c=E-y,A[0]=E-(y+c)+(c-C),v=m+y,c=v-m,P=m-(v-c)+(y-c),y=P-L,c=P-y,A[1]=P-(y+c)+(c-L),S=v+y,c=S-v,A[2]=v-(S-c)+(y-c),A[3]=S;const De=it(Re,mt,4,A,Pt);return Pt[De-1]}function Zt(t,e,r,n,i,o){const s=(e-o)*(r-i),a=(t-i)*(n-o),u=s-a,f=Math.abs(s+a);return Math.abs(u)>=Kt*f?u:-Ht(t,e,r,n,i,o,f)}function jt(t,e){var r,n,i=0,o,s,a,u,f,h,c,l=t[0],p=t[1],g=e.length;for(r=0;r<g;r++){n=0;var d=e[r],w=d.length-1;if(h=d[0],h[0]!==d[w][0]&&h[1]!==d[w][1])throw new Error("First and last coordinates in a ring must be the same");for(s=h[0]-l,a=h[1]-p,n;n<w;n++){if(c=d[n+1],u=c[0]-l,f=c[1]-p,a===0&&f===0){if(u<=0&&s>=0||s<=0&&u>=0)return 0}else if(f>=0&&a<=0||f<=0&&a>=0){if(o=Zt(s,u,a,f,0,0),o===0)return 0;(o>0&&f>0&&a<=0||o<0&&f<=0&&a>0)&&i++}h=c,a=f,s=u}}return i%2!==0}function U(t,e,r={}){if(!t)throw new Error("point is required");if(!e)throw new Error("polygon is required");const n=q(t),i=H(e),o=i.type,s=e.bbox;let a=i.coordinates;if(s&&te(n,s)===!1)return!1;o==="Polygon"&&(a=[a]);let u=!1;for(var f=0;f<a.length;++f){const h=jt(n,a[f]);if(h===0)return!r.ignoreBoundary;h&&(u=!0)}return u}function te(t,e){return e[0]<=t[0]&&e[1]<=t[1]&&e[2]>=t[0]&&e[3]>=t[1]}class Et{constructor(e=[],r=ee){if(this.data=e,this.length=this.data.length,this.compare=r,this.length>0)for(let n=(this.length>>1)-1;n>=0;n--)this._down(n)}push(e){this.data.push(e),this.length++,this._up(this.length-1)}pop(){if(this.length===0)return;const e=this.data[0],r=this.data.pop();return this.length--,this.length>0&&(this.data[0]=r,this._down(0)),e}peek(){return this.data[0]}_up(e){const{data:r,compare:n}=this,i=r[e];for(;e>0;){const o=e-1>>1,s=r[o];if(n(i,s)>=0)break;r[e]=s,e=o}r[e]=i}_down(e){const{data:r,compare:n}=this,i=this.length>>1,o=r[e];for(;e<i;){let s=(e<<1)+1,a=r[s];const u=s+1;if(u<this.length&&n(r[u],a)<0&&(s=u,a=r[u]),n(a,o)>=0)break;r[e]=a,e=s}r[e]=o}}function ee(t,e){return t<e?-1:t>e?1:0}function Mt(t,e){return t.p.x>e.p.x?1:t.p.x<e.p.x?-1:t.p.y!==e.p.y?t.p.y>e.p.y?1:-1:1}function re(t,e){return t.rightSweepEvent.p.x>e.rightSweepEvent.p.x?1:t.rightSweepEvent.p.x<e.rightSweepEvent.p.x?-1:t.rightSweepEvent.p.y!==e.rightSweepEvent.p.y?t.rightSweepEvent.p.y<e.rightSweepEvent.p.y?1:-1:1}class bt{constructor(e,r,n,i){this.p={x:e[0],y:e[1]},this.featureId=r,this.ringId=n,this.eventId=i,this.otherEvent=null,this.isLeftEndpoint=null}isSamePoint(e){return this.p.x===e.p.x&&this.p.y===e.p.y}}function ne(t,e){if(t.type==="FeatureCollection"){const r=t.features;for(let n=0;n<r.length;n++)Lt(r[n],e)}else Lt(t,e)}let Z=0,j=0,tt=0;function Lt(t,e){const r=t.type==="Feature"?t.geometry:t;let n=r.coordinates;(r.type==="Polygon"||r.type==="MultiLineString")&&(n=[n]),r.type==="LineString"&&(n=[[n]]);for(let i=0;i<n.length;i++)for(let o=0;o<n[i].length;o++){let s=n[i][o][0],a=null;j=j+1;for(let u=0;u<n[i][o].length-1;u++){a=n[i][o][u+1];const f=new bt(s,Z,j,tt),h=new bt(a,Z,j,tt+1);f.otherEvent=h,h.otherEvent=f,Mt(f,h)>0?(h.isLeftEndpoint=!0,f.isLeftEndpoint=!1):(f.isLeftEndpoint=!0,h.isLeftEndpoint=!1),e.push(f),e.push(h),s=a,tt=tt+1}}Z=Z+1}class ie{constructor(e){this.leftSweepEvent=e,this.rightSweepEvent=e.otherEvent}}function oe(t,e){if(t===null||e===null||t.leftSweepEvent.ringId===e.leftSweepEvent.ringId&&(t.rightSweepEvent.isSamePoint(e.leftSweepEvent)||t.rightSweepEvent.isSamePoint(e.leftSweepEvent)||t.rightSweepEvent.isSamePoint(e.rightSweepEvent)||t.leftSweepEvent.isSamePoint(e.leftSweepEvent)||t.leftSweepEvent.isSamePoint(e.rightSweepEvent)))return!1;const r=t.leftSweepEvent.p.x,n=t.leftSweepEvent.p.y,i=t.rightSweepEvent.p.x,o=t.rightSweepEvent.p.y,s=e.leftSweepEvent.p.x,a=e.leftSweepEvent.p.y,u=e.rightSweepEvent.p.x,f=e.rightSweepEvent.p.y,h=(f-a)*(i-r)-(u-s)*(o-n),c=(u-s)*(n-a)-(f-a)*(r-s),l=(i-r)*(n-a)-(o-n)*(r-s);if(h===0)return!1;const p=c/h,g=l/h;if(p>=0&&p<=1&&g>=0&&g<=1){const d=r+p*(i-r),w=n+p*(o-n);return[d,w]}return!1}function se(t,e){e=e||!1;const r=[],n=new Et([],re);for(;t.length;){const i=t.pop();if(i.isLeftEndpoint){const o=new ie(i);for(let s=0;s<n.data.length;s++){const a=n.data[s];if(e&&a.leftSweepEvent.featureId===i.featureId)continue;const u=oe(o,a);u!==!1&&r.push(u)}n.push(o)}else i.isLeftEndpoint===!1&&n.pop()}return r}function ae(t,e){const r=new Et([],Mt);return ne(t,r),se(r,e)}var ce=ae;function ot(t,e,r={}){const{removeDuplicates:n=!0,ignoreSelfIntersections:i=!0}=r;let o=[];t.type==="FeatureCollection"?o=o.concat(t.features):t.type==="Feature"?o.push(t):(t.type==="LineString"||t.type==="Polygon"||t.type==="MultiLineString"||t.type==="MultiPolygon")&&o.push(O(t)),e.type==="FeatureCollection"?o=o.concat(e.features):e.type==="Feature"?o.push(e):(e.type==="LineString"||e.type==="Polygon"||e.type==="MultiLineString"||e.type==="MultiPolygon")&&o.push(O(e));const s=ce(Y(o),i);let a=[];if(n){const u={};s.forEach(f=>{const h=f.join(",");u[h]||(u[h]=!0,a.push(f))})}else a=s;return Y(a.map(u=>x(u)))}function V(t,e={}){const r=H(t);switch(!e.properties&&t.type==="Feature"&&(e.properties=t.properties),r.type){case"Polygon":return fe(r,e);case"MultiPolygon":return ue(r,e);default:throw new Error("invalid poly")}}function fe(t,e={}){const n=H(t).coordinates,i=e.properties?e.properties:t.type==="Feature"?t.properties:{};return St(n,i)}function ue(t,e={}){const n=H(t).coordinates,i=e.properties?e.properties:t.type==="Feature"?t.properties:{},o=[];return n.forEach(s=>{o.push(St(s,i))}),Y(o)}function St(t,e){return t.length>1?Gt(t,e):X(t[0],e)}function le(t,e,{ignoreSelfIntersections:r=!0}={ignoreSelfIntersections:!0}){let n=!0;return z(t,i=>{z(e,o=>{if(n===!1)return!1;n=he(i.geometry,o.geometry,r)})}),n}function he(t,e,r){switch(t.type){case"Point":switch(e.type){case"Point":return!ge(t.coordinates,e.coordinates);case"LineString":return!At(e,t);case"Polygon":return!U(t,e)}break;case"LineString":switch(e.type){case"Point":return!At(t,e);case"LineString":return!pe(t,e,r);case"Polygon":return!Ct(e,t,r)}break;case"Polygon":switch(e.type){case"Point":return!U(e,t);case"LineString":return!Ct(t,e,r);case"Polygon":return!ye(e,t,r)}}return!1}function At(t,e){for(let r=0;r<t.coordinates.length-1;r++)if(de(t.coordinates[r],t.coordinates[r+1],e.coordinates))return!0;return!1}function pe(t,e,r){return ot(t,e,{ignoreSelfIntersections:r}).features.length>0}function Ct(t,e,r){for(const i of e.coordinates)if(U(i,t))return!0;return ot(e,V(t),{ignoreSelfIntersections:r}).features.length>0}function ye(t,e,r){for(const i of t.coordinates[0])if(U(i,e))return!0;for(const i of e.coordinates[0])if(U(i,t))return!0;return ot(V(t),V(e),{ignoreSelfIntersections:r}).features.length>0}function de(t,e,r){const n=r[0]-t[0],i=r[1]-t[1],o=e[0]-t[0],s=e[1]-t[1];return n*s-i*o!==0?!1:Math.abs(o)>=Math.abs(s)?o>0?t[0]<=r[0]&&r[0]<=e[0]:e[0]<=r[0]&&r[0]<=t[0]:s>0?t[1]<=r[1]&&r[1]<=e[1]:e[1]<=r[1]&&r[1]<=t[1]}function ge(t,e){return t[0]===e[0]&&t[1]===e[1]}function we(t,e,{ignoreSelfIntersections:r=!0}={}){let n=!1;return z(t,i=>{z(e,o=>{if(n===!0)return!0;n=!le(i.geometry,o.geometry,{ignoreSelfIntersections:r})})}),n}var ve=Object.defineProperty,me=Object.defineProperties,Pe=Object.getOwnPropertyDescriptors,_t=Object.getOwnPropertySymbols,Ee=Object.prototype.hasOwnProperty,Me=Object.prototype.propertyIsEnumerable,Ft=(t,e,r)=>e in t?ve(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,It=(t,e)=>{for(var r in e||(e={}))Ee.call(e,r)&&Ft(t,r,e[r]);if(_t)for(var r of _t(e))Me.call(e,r)&&Ft(t,r,e[r]);return t},kt=(t,e)=>me(t,Pe(e));function be(t,e,r={}){if(!t||!e)throw new Error("lines and pt are required arguments");const n=q(e);let i=x([1/0,1/0],{dist:1/0,index:-1,multiFeatureIndex:-1,location:-1}),o=0;return z(t,function(s,a,u){const f=Nt(s);for(let h=0;h<f.length-1;h++){const c=x(f[h]),l=q(c),p=x(f[h+1]),g=q(p),d=rt(c,p,r);let w,y;g[0]===n[0]&&g[1]===n[1]?[w,y]=[g,!0]:l[0]===n[0]&&l[1]===n[1]?[w,y]=[l,!1]:[w,y]=Ae(l,g,n);const v=x(w,{dist:rt(e,w,r),multiFeatureIndex:u,location:o+rt(c,w,r)});v.properties.dist<i.properties.dist&&(i=kt(It({},v),{properties:kt(It({},v.properties),{index:y?h+1:h})})),o+=d}}),i}function T(t,e){const[r,n,i]=t,[o,s,a]=e;return r*o+n*s+i*a}function J(t,e){const[r,n,i]=t,[o,s,a]=e;return[n*a-i*s,i*o-r*a,r*s-n*o]}function Le(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2))}function Ot(t){const e=Le(t);return[t[0]/e,t[1]/e,t[2]/e]}function st(t){const e=N(t[1]),r=N(t[0]);return[Math.cos(e)*Math.cos(r),Math.cos(e)*Math.sin(r),Math.sin(e)]}function Se(t){const[e,r,n]=t,i=Math.min(Math.max(n,-1),1),o=lt(Math.asin(i));return[lt(Math.atan2(r,e)),o]}function Ae(t,e,r){const n=st(t),i=st(e),o=st(r),s=J(n,i);if(s[0]===0&&s[1]===0&&s[2]===0)return T(n,i)>0?[[...e],!0]:[[...r],!1];const a=J(s,o);if(a[0]===0&&a[1]===0&&a[2]===0)return[[...e],!0];const u=J(a,s),f=Ot(u),h=[-f[0],-f[1],-f[2]],c=T(o,f)>T(o,h)?f:h,l=Ot(s),p=T(J(n,c),l),g=T(J(c,i),l);return p>=0&&g>=0?[Se(c),!1]:T(n,o)>T(i,o)?[[...t],!1]:[[...e],!0]}function at(t,e,r={}){const n=q(t),i=q(e);i[0]+=i[0]-n[0]>180?-360:n[0]-i[0]>180?360:0;const o=Ce(n,i);return ht(o,"meters",r.units)}function Ce(t,e,r){r=r===void 0?M:Number(r);const n=r,i=t[1]*Math.PI/180,o=e[1]*Math.PI/180,s=o-i;let a=Math.abs(e[0]-t[0])*Math.PI/180;a>Math.PI&&(a-=2*Math.PI);const u=Math.log(Math.tan(o/2+Math.PI/4)/Math.tan(i/2+Math.PI/4)),f=Math.abs(u)>1e-11?s/u:Math.cos(i);return Math.sqrt(s*s+f*f*a*a)*n}function xt(t){const e=[];return t.type==="FeatureCollection"?zt(t,function(r){W(r,function(n){e.push(x(n,r.properties))})}):t.type==="Feature"?W(t,function(r){e.push(x(r,t.properties))}):W(t,function(r){e.push(x(r))}),Y(e)}function Rt(t,e,r={}){var n,i;const o=(n=r.method)!=null?n:"geodesic",s=(i=r.units)!=null?i:"kilometers";if(!t)throw new Error("pt is required");if(Array.isArray(t)?t=x(t):t.type==="Point"?t=O(t):yt(t,"Point","point"),!e)throw new Error("line is required");Array.isArray(e)?e=X(e):e.type==="LineString"?e=O(e):yt(e,"LineString","line");let a=1/0;const u=t.geometry.coordinates;return $t(e,f=>{if(f){const h=f.geometry.coordinates[0],c=f.geometry.coordinates[1],l=_e(u,h,c,{method:o});l<a&&(a=l)}}),ht(a,"degrees",s)}function _e(t,e,r,n){if(n.method==="geodesic")return be(X([e,r]).geometry,t,{units:"degrees"}).properties.dist;const i=[r[0]-e[0],r[1]-e[1]],o=[t[0]-e[0],t[1]-e[1]],s=Dt(o,i);if(s<=0)return at(t,e,{units:"degrees"});const a=Dt(i,i);if(a<=s)return at(t,r,{units:"degrees"});const u=s/a,f=[e[0]+u*i[0],e[1]+u*i[1]];return at(t,f,{units:"degrees"})}function Dt(t,e){return t[0]*e[0]+t[1]*e[1]}let et=null,G=null,$=new Map;self.onmessage=async t=>{const{type:e,payload:r}=t.data;if(e==="INIT")try{await Fe(),self.postMessage({type:"READY",countries:et})}catch(n){console.error(n),self.postMessage({type:"ERROR",error:n.message})}else if(e==="FILTER"){if(!et){self.postMessage({type:"ERROR",error:"Data not loaded"});return}const{clues:n,includeTerritories:i}=r,o=Oe(et.features,n,i);self.postMessage({type:"RESULT",candidates:o})}};async function Fe(){try{const[t,e]=await Promise.all([fetch("/world.geojson"),fetch("/distances.json").catch(n=>({ok:!1}))]);if(!t.ok)throw new Error("Failed to load map data");const r=await t.json();if(r.features.forEach(n=>{n._mainland=ct(n)}),et=r,e.ok)try{G=await e.json()}catch{console.warn("Worker: Failed to parse distance matrix")}}catch(t){throw console.error("Worker: Error loading data:",t),t}}function ct(t){if(t.geometry.type==="Polygon")return t;if(t.geometry.type==="MultiPolygon"){let e=0,r=null;if(t.geometry.coordinates.forEach(n=>{const i=qt(n),o=Wt(i);o>e&&(e=o,r=i)}),r)return{type:"Feature",properties:t.properties,geometry:r.geometry}}return t}function Ie(t,e,r){const[n,i]=t<e?[t,e]:[e,t];return`${n}|${i}|${r}`}function ke(t,e,r=!1){const n=t.properties.ISO_A3||t.properties.name,i=e.properties.ISO_A3||e.properties.name,o=Ie(n,i,r);if($.has(o))return $.get(o);if(r&&G){if(G[n]&&G[n][i]!==void 0){const d=G[n][i];return $.set(o,d),d}if(G[i]&&G[i][n]!==void 0){const d=G[i][n];return $.set(o,d),d}}const s=r?t:t._mainland||ct(t),a=r?e:e._mainland||ct(e);if(we(s,a))return $.set(o,0),0;const u=V(a),f=xt(s),h=u.type==="FeatureCollection"?u.features:[u];let c=1/0;for(const d of f.features)for(const w of h)try{const y=Rt(d,w,{units:"kilometers"});y<c&&(c=y)}catch{}const l=V(s),p=xt(a),g=l.type==="FeatureCollection"?l.features:[l];for(const d of p.features)for(const w of g)try{const y=Rt(d,w,{units:"kilometers"});y<c&&(c=y)}catch{}return $.set(o,c),c}function Oe(t,e,r=!1){return t.filter(n=>e.every(i=>{const o=ke(n,i.country,r);if(i.distance===0)return o===0;const s=Math.max(50,i.distance*.05);return Math.abs(o-i.distance)<=s}))}})();
